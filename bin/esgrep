#!/usr/bin/env ruby
require 'net/http'
require 'json'
require 'time'

require 'main'
require 'terminal-table'

Main {
  argument('query'){
    description "A Lucene query string."
  }

  argument('clusters'){
    description "A list of clusters to query."
    arity -2
  }

  option('raw', 'r'){
    description 'Send a raw ElasticSearch REST query.'
  }

  option('field', 'f'){
    description 'Search by field.'
    argument :optional
    defaults '_all'
  }

  option('app', 'a'){
    description 'Filter the search by app name.'
    argument :optional
    defaults '*'
  }

  option('limit', 'l'){
    description 'The maximum number of results to return.'
    argument :optional
    cast :int
    defaults 40
  }

  option('pretty', 'p'){
    description 'Enable pretty printing.'
  }

  option('json', 'j'){
    description 'Output JSON.'
  }

  def run
    results = query_clusters(params[:query].value, params[:clusters].values)

    if params[:json].given?
      print_json(results, params[:pretty].given?)
    else
      print(results, params[:pretty].given?)
    end
  end

  def print_json(results, pretty)
    if pretty
      puts JSON.pretty_generate(results)
    else
      puts JSON.dump(results)
    end
  end

  def print(results, pretty)
    rows = results.map{ |r| 
      f = {}
      r["_source"]["@fields"].each { |k,v| f[k] = extract(v) }

      if pretty
        [
          format_time(f["timestamp"]),
          truncate(f["hostname"], 30),
          truncate(f["appname"], 30),
          truncate(f["procid"], 30),
          truncate(f["message"], 50)
        ] 
      else
        [
          f["timestamp"],
          f["hostname"],
          f["appname"],
          f["procid"],
          f["message"]
        ] 
      end
    }

    style = {}
    unless pretty
      style = { :border_x => " ", :border_y => " ", :border_i => " "}
    end

    table = Terminal::Table.new( 
      :headings => ['Timestamp', 'Hostname', 'App Name', 'Process ID', 'Message'],
      :rows => rows,
      :style => style
    )

    puts table
  end

  def extract(val)
    val = *val
    val.empty? ? "" : val.first
  end

  def truncate(val, len)
    val ||= ""
    val[0..len]
  end

  def format_time(val)
    Time.parse(val).strftime("%Y-%m-%d %H:%M")
  rescue
    ""
  end

  def query_clusters(query, clusters)
    results = clusters.map{ |c| query_cluster(query, c) }.flatten
    results.sort_by { |r| -r["_score"].to_i } .take(params[:limit].value)
  end

  def query_cluster(query, cluster)
    http = Net::HTTP.new(cluster)
    response = http.post('/_search', query_string(query))
    JSON.parse(response.body)["hits"]["hits"]
  end

  def query_string(query)
    if params[:raw].given?
      query.to_json
    else
      {
        "from" => 0, "size" => params[:limit].value,

        "query" => {
            "query_string" => {
              "query" => query,
              "default_field" => params[:field].value
            }
          },

          "filter" => {
            "query" => {
              "query_string" => {
                "query" => params[:app].value,
                "default_field" => "appname"
              }
            }
          }
          
      }.to_json
    end
  end

}